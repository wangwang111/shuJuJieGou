队列
Queue<Node> queue=new LinkedList<>();
offer() 	插入元素到队列尾部
poll()		获取并移除列表的头（第一个元素）
peek()		获取但不移除此列表的头（第一个元素）

堆
Stack<Node> stack=new Stack()<>;
push()		压入元素到堆顶部
pop() 		移除对顶元素，并返回
peek() 		查看对顶元素，但不堆栈中移除它


位运算的常见操作符
&	相同位的两个数组都为1，则为1；若一个不为0，则为0
|	相同位只要一个为1即为1
^	相同位不同则为1，相同则为0
~	内存中的0和1全部取反
<
<<  左移右侧补0		乘以2的操作请尽量用左移一位来代替
>
>>	右移左侧补0		替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2
>>> 

&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式


什么是动态规划?
求一个问题的最优解（通常是求最大值或者最小值），而且该问题能够分解成若干个子问题，
并且子问题之间还有重叠的更小问题，可以考虑动态规划

应用动态规划之前要分析能否把大问题分解成小问题，分解后每个小问题也存在最优解，如果小问题的最优解组合起来能够
得到整个问题的最优解，那么可以应用动态规划
特点：
1.求一个问题的最优解
2.整体问题的的最右解是依赖各个子问题的最优解
3.把大问题分解成若干个小问题，这些小问题之间还有相互重叠的更小问题
4.从上往下分析问题，从下往上求解问题
